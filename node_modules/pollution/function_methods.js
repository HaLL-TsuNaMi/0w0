const utility = require("./utility")

const bench = function(f, ...args) {
	const start = process.hrtime()
	f(...args)
	const numberGen = function* (n) {
		//TODO use recrusion
		const floor = Math.floor
		const numberInMs = n / 1000000
		const msPart = (numberInMs < 0) ? 0 : floor(numberInMs)
		yield msPart
		const numberInUs = (numberInMs - msPart) * 1000
		const usPart = (numberInUs < 0) ? 0 :floor(numberInUs)
		yield usPart
		const numberInNs = (numberInUs - usPart) * 1000
		const nsPart = floor(numberInNs)
		yield nsPart
	}

	const [secPart, nanoPart] = process.hrtime(start)
	const [s, ms, us, ns] = [secPart, ...numberGen(nanoPart)]
	const [
		sFmt,
		msFmt,
		usFmt,
		nsFmt,
	] = [...Object.entries({s, ms, us, ns}).map(([k, v]) => {
		return v ? `${v}${k} ` : ""
	})]
	return (sFmt + msFmt + usFmt + nsFmt).trimRight()
}


const memorize = (f) => {
	const cache = new Map()
	return (...args)=> {
		const key = JSON.stringify(args)
		const optValue = cache.get(key)
		if(optValue) {
			return optValue  
		} else {
			const newValue = f(...args)
			cache.set(key, newValue)
			return newValue
		}
	}
}

const fib = (n)=> {
	const f = (step = 3, last = 1, lastLast = 1)=> {
		if(step == n) {
			return last + lastLast
		}
		return f(step + 1, last + lastLast, last) 
	}
	return f()
}

const functionMethods = {}
functionMethods.define("bench", bench)
functionMethods.define("fib", fib)
functionMethods.define("memorize", memorize)

utility.setMethodPairs(functionMethods, Function)
Object.freeze(Function.prototype)
