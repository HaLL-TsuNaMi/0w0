const utility = require("./utility")
const define = function(prop, value, mode = "e" ) {
	const configurable = mode.indexOf("c") !== -1 ? true : false;
	const enumerable = mode.indexOf("e") !== -1 ? true : false;
	if(mode.indexOf("g") !== -1 || mode.indexOf("s") !== -1) {
		const { get, set } = valueOrObj
		Reflect.defineProperty(this, prop, {
			configurable: configurable,
			enumerable: enumerable,
			get: get,
			set: set,
		});
	} else {
		const writable = mode.indexOf("w") !== -1 ? true : false;
		Reflect.defineProperty(this, prop, {
			configurable: configurable,
			enumerable: enumerable,
			writable: writable,
			value: value,
		});
	}
}

const _compareKeys = (a, b)=> {
	const keysOfA = Object.keys(a)
	const keysOfB = Object.keys(b)
	if(keysOfA.length === 0 && keysOfB.length === 0)
		return true
	if(keysOfA.length === 0 || keysOfB.length === 0)
		return false
	keysOfA.forEach((e, i)=> {
		if(keysOfB[i] !== e)
			return false	
	})
	return true
}

const _compare = (a, b, keys)=> {
	if(keys.length === 0 )
		return true
	let key = keys.pop()	
	if(typeof a[key] === "object" && typeof b[key] === "object")
		if(!deepEqual(a[key], b[key]))
			return false
		else
			key = keys.pop()
	if(a[key] !== b[key])
		return false
	return _compare(a, b, keys)
}

const deepEqual = (a, b)=> {
	if(!_compareKeys(a, b))
		return false
	return _compare(a, b, Object.keys(a))
}

const objectProtoMethods = {}
const objectStaticMethods = {}

define.call(objectProtoMethods, "define", define)
define.call(objectStaticMethods, "deepEqual", deepEqual)

utility.setMethodPairs(objectProtoMethods, Object.prototype)
utility.setMethodPairs(objectStaticMethods, Object)

Object.freeze(Object)
Object.freeze(Object.prototype)
